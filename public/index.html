<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Site Builder</title>
  <style>
    :root {
      --bg: #f5f8fb;
      --panel-bg: #ffffff;
      --panel-border: #dbe4ef;
      --text: #162434;
      --muted: #5e748d;
      --accent: #1276d1;
      --accent-ink: #ffffff;
      --ai-bubble: #eef5fb;
      --me-bubble: #e8f7ef;
      --btn-bg: #f3f7fb;
      --btn-border: #ccd9e8;
    }
    body {
      font-family: "Times New Roman", Georgia, serif;
      max-width: 920px;
      margin: 24px auto;
      padding: 0 12px;
      color: var(--text);
      background:
        radial-gradient(circle at top right, #ddeeff 0%, rgba(221,238,255,0) 35%),
        radial-gradient(circle at bottom left, #dcf6e8 0%, rgba(220,246,232,0) 35%),
        var(--bg);
    }
    .pageTitle {
      text-align: center;
      font-size: 28px;
      letter-spacing: 0.12em;
      font-weight: 700;
      text-transform: uppercase;
      margin: 8px 0 16px;
      color: #123050;
    }
    .topRibbon {
      display: grid;
      grid-template-columns: 1fr auto 1fr;
      align-items: center;
      gap: 16px;
      margin: 6px 0 16px;
    }
    .ribbonLeft {
      display: flex;
      align-items: center;
      gap: 10px;
      justify-content: flex-start;
    }
    .ribbonRight {
      display: flex;
      align-items: center;
      gap: 8px;
      justify-content: flex-end;
      flex-wrap: wrap;
    }
    .jackpotCard {
      display: flex;
      align-items: center;
      gap: 8px;
      border-radius: 12px;
      border: 1px solid #b7c7db;
      background: linear-gradient(180deg, #ffffff, #eef4fb);
      padding: 8px 10px;
      box-shadow: 0 8px 20px rgba(17, 49, 86, 0.12);
    }
    .jackpotLabel {
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      color: #1d4f81;
      font-weight: 700;
    }
    .jackpotDigits {
      font-family: "Courier New", Courier, monospace;
      font-size: 18px;
      font-weight: 700;
      background: #0f2338;
      color: #e7f2ff;
      padding: 6px 10px;
      border-radius: 8px;
      letter-spacing: 0.2em;
      border: 1px solid #2b4d6a;
      min-width: 120px;
      text-align: center;
    }
    .jackpotHint {
      font-size: 11px;
      color: #4d6a85;
      max-width: 220px;
      line-height: 1.3;
    }
    .frameworkBadge {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 6px 8px;
      border-radius: 999px;
      border: 1px solid #c6d3e0;
      background: #ffffff;
      font-size: 11px;
      color: #193655;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      font-weight: 700;
    }
    .frameworkBadge img {
      width: 16px;
      height: 16px;
    }
    @media (max-width: 720px) {
      .topRibbon {
        grid-template-columns: 1fr;
        justify-items: center;
      }
      .ribbonLeft,
      .ribbonRight {
        justify-content: center;
      }
      .jackpotHint {
        max-width: none;
        text-align: center;
      }
    }
    #chat {
      border: 1px solid var(--panel-border);
      border-radius: 14px;
      padding: 14px;
      height: 65vh;
      overflow: auto;
      background: var(--panel-bg);
      box-shadow: 0 12px 30px rgba(21, 44, 75, 0.08);
      margin: 0 auto;
    }
    .msg { margin: 10px 0; white-space: pre-wrap; line-height: 1.35; }
    .ai { color: var(--text); }
    .me { color: #0e6a3c; text-align: right; }
    .bubble {
      display: inline-block;
      padding: 10px 12px;
      border-radius: 12px;
      max-width: 92%;
      border: 1px solid var(--panel-border);
    }
    .ai .bubble { background: var(--ai-bubble); }
    .me .bubble { background: var(--me-bubble); }
    a { color: #0e5ea8; text-decoration: underline; }
    form { display:flex; gap:8px; margin-top: 10px; }
    input { flex:1; padding: 12px; border-radius: 10px; border:1px solid var(--btn-border); }
    button { padding: 12px 14px; border-radius: 10px; border:1px solid var(--btn-border); background: var(--btn-bg); cursor:pointer; }
    button:disabled { opacity: 0.5; cursor:not-allowed; }

    #quickBar { display:none; gap:10px; margin-top: 10px; }
    .qr { flex:1; padding: 12px 14px; border-radius: 10px; border:1px solid var(--btn-border); background:#fff; cursor:pointer; }
    .qr.primary { background: var(--accent); color: var(--accent-ink); border-color: var(--accent); }
    #smartBar { display:none; gap:8px; margin-top: 8px; flex-wrap:wrap; }
    .smartBtn { padding:9px 11px; border-radius: 999px; border:1px solid var(--btn-border); background:#fff; color: var(--text); cursor:pointer; font-size: 13px; }
    .smartBtn:hover { border-color: #9cb4ce; }
    #actionBar { display:none; gap:8px; margin-top:10px; flex-wrap:wrap; }
    .actionBtn { padding:10px 12px; border-radius:10px; border:1px solid #2d4d71; background:#fff; color:#163454; cursor:pointer; }
    .actionBtn.primary { background:#173b62; color:#fff; }
    .ctaRow { margin-top: 10px; display:flex; gap:8px; flex-wrap:wrap; }
    .ctaBtn { display:inline-block; padding:10px 12px; border-radius:10px; border:1px solid #2d4d71; text-decoration:none; color:#163454; background:#fff; font-size:14px; }
    .ctaBtn.primary { background:#173b62; color:#fff; }
    .paletteRow {
      margin-top: 10px;
      display: grid;
      gap: 12px;
      grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
    }
    .paletteCard {
      border: 1px solid #cfdeee;
      border-radius: 14px;
      background: linear-gradient(180deg, #ffffff, #f7fbff);
      padding: 11px;
      box-shadow: 0 8px 22px rgba(20, 53, 86, 0.08);
      transition: transform 0.14s ease, box-shadow 0.14s ease, border-color 0.14s ease;
    }
    .paletteCard:hover {
      transform: translateY(-2px);
      border-color: #9bb6d4;
      box-shadow: 0 12px 26px rgba(20, 53, 86, 0.14);
    }
    .paletteMeta {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      margin-bottom: 6px;
    }
    .paletteTag {
      font-size: 11px;
      font-weight: 700;
      letter-spacing: 0.05em;
      text-transform: uppercase;
      color: #1d4f81;
      border: 1px solid #b8cbe0;
      border-radius: 999px;
      padding: 3px 8px;
      background: #edf4fb;
    }
    .paletteTitle {
      font-size: 14px;
      font-weight: 700;
      margin-bottom: 4px;
      color: #173b62;
      line-height: 1.2;
    }
    .paletteHint {
      font-size: 12px;
      color: var(--muted);
      margin-bottom: 8px;
      min-height: 30px;
    }
    .palettePreview {
      width: 100%;
      height: 34px;
      border-radius: 10px;
      border: 1px solid #bdd0e5;
      margin-bottom: 8px;
      background: linear-gradient(90deg, #f1f5f9, #dbe8f4);
    }
    .paletteSwatches {
      display: grid;
      grid-template-columns: repeat(5, minmax(0, 1fr));
      gap: 6px;
      margin-bottom: 9px;
    }
    .paletteSwatch {
      border-radius: 9px;
      overflow: hidden;
      border: 1px solid #a3b7cc;
      background: #fff;
    }
    .paletteDot {
      width: 100%;
      height: 30px;
      border: 0;
      border-radius: 0;
    }
    .paletteHex {
      display: block;
      font-size: 10px;
      line-height: 1;
      text-align: center;
      padding: 5px 3px;
      color: #304f70;
      background: #fff;
      letter-spacing: 0.02em;
    }
    .palettePickBtn {
      width: 100%;
      padding: 9px 10px;
      border-radius: 10px;
      border: 1px solid #9eb7d1;
      background: linear-gradient(180deg, #fafdff, #edf4fb);
      cursor: pointer;
      font-size: 12px;
      font-weight: 700;
      color: #173b62;
      transition: border-color 0.14s ease, box-shadow 0.14s ease, transform 0.14s ease;
    }
    .palettePickBtn:hover {
      border-color: #5f85ab;
      box-shadow: 0 6px 14px rgba(28, 68, 110, 0.16);
      transform: translateY(-1px);
    }
    .palettePickBtn:disabled {
      opacity: 0.62;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }
    #startPanel {
      border: 1px solid #cdddf0;
      border-radius: 14px;
      background:
        linear-gradient(180deg, rgba(255,255,255,0.98), rgba(245,250,255,0.98));
      padding: 14px;
      margin-bottom: 10px;
      box-shadow: 0 8px 24px rgba(24, 49, 80, 0.08);
    }
    .startTitle {
      font-size: 15px;
      font-weight: 700;
      color: #153350;
      text-align: center;
      letter-spacing: 0.02em;
    }
    .startSub {
      margin-top: 4px;
      color: var(--muted);
      font-size: 13px;
      text-align: center;
    }
    .startRow {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
      gap: 8px;
      margin-top: 10px;
    }
    .startBtn {
      padding: 10px 11px;
      border-radius: 10px;
      border: 1px solid var(--btn-border);
      background: #fff;
      cursor: pointer;
      font-size: 14px;
      display: inline-flex;
      align-items: center;
      gap: 8px;
      justify-content: flex-start;
      text-align: left;
      transition: transform 0.12s ease, box-shadow 0.12s ease, border-color 0.12s ease;
    }
    .startBtn:hover {
      transform: translateY(-1px);
      border-color: #8aabd0;
      box-shadow: 0 8px 18px rgba(35, 70, 110, 0.12);
    }
    .startBtn.primary {
      background: #173b62;
      color: #fff;
      border-color: #173b62;
    }
    .startIconWrap {
      width: 20px;
      height: 20px;
      border-radius: 6px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      background: #eff5fb;
      border: 1px solid #c8d9ec;
      flex: 0 0 20px;
    }
    .startBtn.primary .startIconWrap {
      background: rgba(255, 255, 255, 0.18);
      border-color: rgba(255, 255, 255, 0.35);
      color: #fff;
    }
    .startIcon {
      width: 16px;
      height: 16px;
      border-radius: 4px;
      display: block;
    }
    .startLabel {
      line-height: 1.1;
      font-weight: 600;
      letter-spacing: 0.1px;
    }
    .startHint {
      margin-top: 8px;
      color: var(--muted);
      font-size: 13px;
    }
    #billingPanel {
      margin-top: 12px;
      border: 1px solid #cdddf0;
      border-radius: 12px;
      padding: 10px 12px;
      background: #f7fbff;
      box-shadow: inset 0 1px 0 rgba(255,255,255,0.6);
    }
    .billingTitle {
      font-size: 13px;
      font-weight: 700;
      color: #153350;
      margin-bottom: 4px;
    }
    .billingLine {
      font-size: 12px;
      color: var(--muted);
      margin-top: 2px;
      line-height: 1.35;
    }
    .billingActions {
      margin-top: 8px;
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }
    .billingBtn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 8px 10px;
      border-radius: 10px;
      border: 1px solid #2d4d71;
      background: #fff;
      color: #163454;
      font-size: 12px;
      text-decoration: none;
    }
    .billingBtn.primary {
      background: #173b62;
      color: #fff;
    }
    @media (max-width: 560px) {
      .startRow { grid-template-columns: 1fr 1fr; }
    }
  </style>
</head>
<body>
  <div class="topRibbon">
    <div class="ribbonLeft">
      <div class="jackpotCard">
        <div>
          <div class="jackpotLabel">Builder Jackpot</div>
          <div class="jackpotDigits" id="jackpotDigits">000000</div>
        </div>
      </div>
      <div class="jackpotHint">
        Authenticate and build a one‑page site to enter the early‑adopter reward pool.
      </div>
    </div>
    <div class="pageTitle">Site Builder</div>
    <div class="ribbonRight">
      <div class="frameworkBadge">
        <img src="https://www.google.com/s2/favicons?sz=64&domain_url=nextjs.org" alt="Next.js"/>
        Next.js
      </div>
      <div class="frameworkBadge">
        <img src="https://www.google.com/s2/favicons?sz=64&domain_url=astro.build" alt="Astro"/>
        Astro
      </div>
      <div class="frameworkBadge">
        <img src="https://www.google.com/s2/favicons?sz=64&domain_url=react.dev" alt="React"/>
        React
      </div>
      <div class="frameworkBadge">
        <img src="https://www.google.com/s2/favicons?sz=64&domain_url=tailwindcss.com" alt="Tailwind"/>
        Tailwind
      </div>
    </div>
  </div>
  <div id="startPanel">
    <div class="startTitle">Choose how you want to sign in</div>
    <div class="startSub">Wallet sign-in is one click. No copy/paste of wallet addresses.</div>
    <div class="startRow">
      <button class="startBtn primary" id="startNameBtn" type="button">
        <span class="startIconWrap" aria-hidden="true">N</span>
        <span class="startLabel">Use Name</span>
      </button>
      <button class="startBtn" id="walletMetaMaskBtn" type="button">
        <span class="startIconWrap"><img class="startIcon" src="https://www.google.com/s2/favicons?sz=64&domain_url=metamask.io" alt="MetaMask icon"/></span>
        <span class="startLabel">MetaMask</span>
      </button>
      <button class="startBtn" id="walletConnectBtn" type="button">
        <span class="startIconWrap"><img class="startIcon" src="https://www.google.com/s2/favicons?sz=64&domain_url=walletconnect.com" alt="WalletConnect icon"/></span>
        <span class="startLabel">WalletConnect</span>
      </button>
      <button class="startBtn" id="walletLedgerBtn" type="button">
        <span class="startIconWrap"><img class="startIcon" src="https://www.google.com/s2/favicons?sz=64&domain_url=ledger.com" alt="Ledger icon"/></span>
        <span class="startLabel">Ledger</span>
      </button>
      <button class="startBtn" id="walletPhantomBtn" type="button">
        <span class="startIconWrap"><img class="startIcon" src="https://www.google.com/s2/favicons?sz=64&domain_url=phantom.app" alt="Phantom icon"/></span>
        <span class="startLabel">Phantom</span>
      </button>
    </div>
    <div class="startHint" id="startHint">Wallet sign-in never asks you to copy/paste a public address.</div>
    <div id="billingPanel" style="display:none;">
      <div class="billingTitle">Starter tokens and pricing</div>
      <div class="billingLine" id="billingStarter">Loading starter balance...</div>
      <div class="billingLine" id="billingPricing"></div>
      <div class="billingLine" id="billingBalance" style="display:none;"></div>
      <div class="billingActions" id="billingActions" style="display:none;"></div>
    </div>
  </div>
  <div id="chat"></div>

  <div id="quickBar">
    <button class="qr primary" id="btnYes" type="button">Yes</button>
    <button class="qr" id="btnNo" type="button">No</button>
  </div>
  <div id="smartBar"></div>
  <div id="actionBar"></div>

  <form id="form">
    <input id="input" placeholder="Type here..." autocomplete="off" disabled/>
    <button type="submit" id="sendBtn" disabled>Send</button>
  </form>
  <div id="turnstileMount" style="display:none;"></div>

  <script>
    const PRIMARY_WORKER_BASE = "https://api.cardetailingreno.com";
    const FALLBACK_WORKER_BASE = "https://sitebuilder-agent.96psxbzqk2.workers.dev";
    let sessionId = null;
    let state = null;

    const chat = document.getElementById("chat");
    const input = document.getElementById("input");
    const form = document.getElementById("form");
    const startPanel = document.getElementById("startPanel");
    const startHint = document.getElementById("startHint");
    const startNameBtn = document.getElementById("startNameBtn");
    const walletMetaMaskBtn = document.getElementById("walletMetaMaskBtn");
    const walletConnectBtn = document.getElementById("walletConnectBtn");
    const walletLedgerBtn = document.getElementById("walletLedgerBtn");
    const walletPhantomBtn = document.getElementById("walletPhantomBtn");
    const quickBar = document.getElementById("quickBar");
    const smartBar = document.getElementById("smartBar");
    const actionBar = document.getElementById("actionBar");
    const btnYes = document.getElementById("btnYes");
    const btnNo = document.getElementById("btnNo");
    const sendBtn = document.getElementById("sendBtn");
    const billingPanel = document.getElementById("billingPanel");
    const billingStarter = document.getElementById("billingStarter");
    const billingPricing = document.getElementById("billingPricing");
    const billingBalance = document.getElementById("billingBalance");
    const billingActions = document.getElementById("billingActions");
    let autoAdvanceTimer = null;
    let pendingRequest = false;
    let walletSession = null;
    let onchainClaimShown = false;
    let securityConfig = {
      turnstile_required: false,
      turnstile_site_key: null,
      wallet_login_enabled: true,
      walletconnect_project_id: null,
    };
    let turnstileScriptPromise = null;
    let walletConnectScriptPromise = null;
    let walletConnectProvider = null;
    let turnstileWidgetId = null;
    let turnstileResolve = null;
    let turnstileReject = null;
    const jackpotDigits = document.getElementById("jackpotDigits");
    let jackpotBase = 120000;
    let jackpotTimer = null;
    let jackpotBump = 0;

    function formatJackpot(n) {
      const v = Math.max(0, Math.floor(Number(n) || 0));
      return String(v).padStart(6, "0");
    }

    function startJackpotTicker() {
      if (!jackpotDigits) return;
      if (jackpotTimer) clearInterval(jackpotTimer);
      jackpotTimer = setInterval(() => {
        jackpotBump += 3 + Math.floor(Math.random() * 5);
        jackpotDigits.textContent = formatJackpot(jackpotBase + jackpotBump);
      }, 1400);
      jackpotDigits.textContent = formatJackpot(jackpotBase);
    }

    function bumpJackpotOnAuth() {
      if (!jackpotDigits) return;
      jackpotBump += 250 + Math.floor(Math.random() * 300);
      jackpotDigits.textContent = formatJackpot(jackpotBase + jackpotBump);
    }

    async function workerFetch(path, options = {}) {
      const primaryUrl = `${PRIMARY_WORKER_BASE}${path}`;
      let primaryResponse = null;
      try {
        primaryResponse = await fetch(primaryUrl, options);
      } catch {}

      const shouldFallback =
        !primaryResponse ||
        [520, 521, 522, 523, 525, 526, 530].includes(primaryResponse.status);

      if (!shouldFallback) return primaryResponse;
      return fetch(`${FALLBACK_WORKER_BASE}${path}`, options);
    }

    function formatPricingModel(model) {
      if (!model) return "";
      const base = Number(model.base_tokens || 0);
      const perPage = Number(model.per_page_tokens || 0);
      const perWords = Number(model.per_30_words_tokens || 0);
      const perComplex = Number(model.per_complexity_unit_tokens || 0);
      return `Pricing is based on estimated token usage per request. Estimated formula: ${base} base + ${perPage}/page + ${perWords} per 30 words + ${perComplex} per complexity unit.`;
    }

    function setBillingActions(urls = []) {
      if (!billingActions) return;
      billingActions.innerHTML = "";
      const valid = urls.filter((u) => typeof u === "string" && u.trim());
      if (!valid.length) {
        billingActions.style.display = "none";
        return;
      }
      billingActions.style.display = "flex";
      valid.forEach((url, idx) => {
        const a = document.createElement("a");
        a.className = "billingBtn" + (idx === 0 ? " primary" : "");
        a.href = url;
        a.target = "_blank";
        a.rel = "noopener noreferrer";
        a.textContent = idx === 0 ? "Top up tokens" : "Buy points";
        billingActions.appendChild(a);
      });
    }

    function renderBillingConfig(cfg) {
      if (!billingPanel || !billingStarter || !billingPricing) return;
      const spl = String(cfg?.spl_symbol || "SPL");
      const freeTokens = Number(cfg?.free_tokens || 0);
      const freePoints = Number(cfg?.free_points || 0);
      const pointsSymbol = String(cfg?.points_symbol || "PTS");
      const pointsEnabled = cfg?.points_enabled === true;
      const llmBackend = String(cfg?.llm_backend || "external");
      const gpuBilling = cfg?.gpu_billing_enabled === true;
      const gpuEndpointRaw = String(cfg?.gpu_endpoint || "").trim();
      let gpuEndpoint = "";
      if (gpuEndpointRaw) {
        try {
          const u = new URL(gpuEndpointRaw);
          gpuEndpoint = u.hostname || gpuEndpointRaw;
        } catch {
          gpuEndpoint = gpuEndpointRaw.split("/")[0] || gpuEndpointRaw;
        }
      }
      const starterParts = [];
      if (freeTokens > 0) starterParts.push(`Wallet sign-in gives you ${freeTokens} ${spl} starter tokens.`);
      if (pointsEnabled && freePoints > 0) starterParts.push(`Name sign-in gets ${freePoints} ${pointsSymbol} starter points.`);
      if (!starterParts.length) starterParts.push("Starter tokens are not enabled yet.");
      starterParts.push(`GPU billing: ${gpuBilling ? "on" : "off"} (${llmBackend}).`);
      if (gpuEndpoint) starterParts.push(`GPU endpoint: ${gpuEndpoint}.`);
      billingStarter.textContent = starterParts.join(" ");
      billingPricing.textContent = formatPricingModel(cfg?.pricing_model);
      billingPanel.style.display = "block";
      setBillingActions([cfg?.topup_url, cfg?.points_topup_url]);
    }

    function renderBillingStatus(status) {
      if (!billingBalance) return;
      const spl = String(status?.spl_symbol || "SPL");
      const pointsSymbol = String(status?.points_symbol || "PTS");
      const tokenBal = Number(status?.token_balance || 0);
      const pointsBal = Number(status?.points_balance || 0);
      const parts = [];
      parts.push(`Current balance: ${tokenBal} ${spl} tokens.`);
      if (status?.points_enabled) parts.push(`${pointsBal} ${pointsSymbol} points.`);
      billingBalance.textContent = parts.join(" ");
      billingBalance.style.display = "block";
      setBillingActions([status?.topup_url, status?.points_topup_url]);
    }

    async function loadBillingConfig() {
      try {
        const r = await workerFetch("/billing/config", { method: "GET" });
        const data = await r.json();
        if (!r.ok || !data?.ok) return;
        renderBillingConfig(data);
      } catch {}
    }

    async function loadBillingStatus() {
      if (!sessionId) return;
      try {
        const r = await workerFetch(`/billing/status?session_id=${encodeURIComponent(sessionId)}`, { method: "GET" });
        const data = await r.json();
        if (!r.ok || !data?.ok) return;
        renderBillingStatus(data.billing || {});
      } catch {}
    }


    function escapeHtml(s) {
      return String(s)
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#039;");
    }

    function linkify(text) {
      const safe = escapeHtml(text);
      const urlRe = /(https?:\/\/[^\s)]+)|(\b([a-z0-9-]+\.)+[a-z]{2,}(\/[^\s)]*)?\b)/ig;
      return safe.replace(urlRe, (m) => {
        const href = m.startsWith("http") ? m : ("https://" + m);
        return `<a href="${href}" target="_blank" rel="noopener noreferrer">${m}</a>`;
      });
    }

    function addMsg(who, text) {
      const row = document.createElement("div");
      row.className = "msg " + who;

      const bubble = document.createElement("div");
      bubble.className = "bubble";
      bubble.innerHTML = linkify(text);

      row.appendChild(bubble);
      chat.appendChild(row);
      chat.scrollTop = chat.scrollHeight;
    }

    function openSite(url) {
      try { window.open(url, "_blank", "noopener,noreferrer"); } catch {}
    }

    function addDemoButton(demoUrl) {
      const a = document.createElement("a");
      a.href = demoUrl;
      a.target = "_blank";
      a.rel = "noopener noreferrer";
      a.textContent = "Open Example Site (new tab)";
      a.style.display = "inline-block";
      a.style.marginTop = "8px";
      a.style.padding = "10px 12px";
      a.style.border = "1px solid #ddd";
      a.style.borderRadius = "10px";
      a.style.textDecoration = "none";
      chat.appendChild(a);
      chat.scrollTop = chat.scrollHeight;
    }

    function addOpenLinkButton(url, label = "Open Link (new tab)") {
      const safe = String(url || "").trim();
      if (!safe) return;
      const a = document.createElement("a");
      a.href = safe;
      a.target = "_blank";
      a.rel = "noopener noreferrer";
      a.textContent = label;
      a.style.display = "inline-block";
      a.style.marginTop = "8px";
      a.style.padding = "10px 12px";
      a.style.border = "1px solid var(--btn-border)";
      a.style.borderRadius = "10px";
      a.style.textDecoration = "none";
      a.style.background = "#fff";
      chat.appendChild(a);
      chat.scrollTop = chat.scrollHeight;
    }

    function addColorSwatches(colors) {
      const list = Array.isArray(colors) ? colors : [];
      if (!list.length) return;

      const row = document.createElement("div");
      row.className = "msg ai";

      const wrap = document.createElement("div");
      wrap.className = "bubble";
      wrap.style.display = "inline-flex";
      wrap.style.gap = "10px";
      wrap.style.alignItems = "center";
      wrap.style.flexWrap = "wrap";
      wrap.style.maxWidth = "100%";

      for (const c of list.slice(0, 6)) {
        const chip = document.createElement("div");
        chip.style.display = "inline-flex";
        chip.style.alignItems = "center";
        chip.style.gap = "6px";
        chip.style.padding = "4px 7px";
        chip.style.border = "1px solid #c6d5e4";
        chip.style.borderRadius = "999px";
        chip.style.background = "#fff";
        const sw = document.createElement("div");
        sw.title = c;
        sw.style.width = "18px";
        sw.style.height = "18px";
        sw.style.borderRadius = "5px";
        sw.style.border = "1px solid #7f94aa";
        sw.style.background = c;
        const hex = document.createElement("span");
        hex.style.fontSize = "12px";
        hex.style.color = "var(--muted)";
        hex.textContent = c;
        chip.appendChild(sw);
        chip.appendChild(hex);
        wrap.appendChild(chip);
      }

      row.appendChild(wrap);
      chat.appendChild(row);
      chat.scrollTop = chat.scrollHeight;
    }

    function addPaletteOptions(palettes) {
      const list = Array.isArray(palettes) ? palettes : [];
      if (!list.length) return;

      const row = document.createElement("div");
      row.className = "paletteRow";

      for (const p of list.slice(0, 3)) {
        const id = String(p?.id || "").trim().toUpperCase();
        const name = String(p?.name || "").trim();
        const desc = String(p?.description || "").trim();
        const colors = Array.isArray(p?.colors) ? p.colors.slice(0, 5) : [];

        const card = document.createElement("div");
        card.className = "paletteCard";

        const meta = document.createElement("div");
        meta.className = "paletteMeta";
        const tag = document.createElement("span");
        tag.className = "paletteTag";
        tag.textContent = id ? `Palette ${id}` : "Palette";
        meta.appendChild(tag);
        card.appendChild(meta);

        const title = document.createElement("div");
        title.className = "paletteTitle";
        title.textContent = name || "Brand Direction";
        card.appendChild(title);

        if (desc) {
          const hint = document.createElement("div");
          hint.className = "paletteHint";
          hint.textContent = desc;
          card.appendChild(hint);
        }

        const preview = document.createElement("div");
        preview.className = "palettePreview";
        if (colors.length) {
          preview.style.background = `linear-gradient(90deg, ${colors.join(", ")})`;
        }
        card.appendChild(preview);

        const swatches = document.createElement("div");
        swatches.className = "paletteSwatches";
        for (const color of colors) {
          const sw = document.createElement("div");
          sw.className = "paletteSwatch";
          const dot = document.createElement("div");
          dot.className = "paletteDot";
          dot.style.background = String(color || "#ddd");
          dot.title = String(color || "");
          const hex = document.createElement("span");
          hex.className = "paletteHex";
          hex.textContent = String(color || "").toUpperCase();
          sw.appendChild(dot);
          sw.appendChild(hex);
          swatches.appendChild(sw);
        }
        card.appendChild(swatches);

        const pickBtn = document.createElement("button");
        pickBtn.type = "button";
        pickBtn.className = "palettePickBtn";
        pickBtn.textContent = `Choose ${id || "this palette"}`;
        pickBtn.addEventListener("click", async () => {
          if (pendingRequest) return;
          for (const b of row.querySelectorAll(".palettePickBtn")) b.disabled = true;
          const answer = id || "palette";
          addMsg("me", answer);
          try {
            await callWorkerAnswer(answer);
          } catch {
            addMsg("ai", "Network/CORS error. Check DevTools console.");
            setRequestPending(false);
          } finally {
            for (const b of row.querySelectorAll(".palettePickBtn")) b.disabled = false;
          }
        });
        card.appendChild(pickBtn);
        row.appendChild(card);
      }

      if (!row.childElementCount) return;
      chat.appendChild(row);
      chat.scrollTop = chat.scrollHeight;
    }

    function addCtaActions(actions) {
      const list = Array.isArray(actions) ? actions : [];
      if (!list.length) return;
      const row = document.createElement("div");
      row.className = "ctaRow";

      for (const action of list.slice(0, 3)) {
        if (!action || !action.url) continue;
        const a = document.createElement("a");
        a.href = action.url;
        a.target = "_blank";
        a.rel = "noopener noreferrer";
        a.className = "ctaBtn" + (action.id === "connect_cloudflare" ? " primary" : "");
        a.textContent = action.label || "Open";
        row.appendChild(a);
      }

      if (!row.childElementCount) return;
      chat.appendChild(row);
      chat.scrollTop = chat.scrollHeight;
    }

    function actionPriority(id) {
      const order = {
        install_ai_webadmin_plugin: 1,
        connect_cloudflare: 2,
        install_tolldns_required: 3,
        signup_github_backup: 4,
        migrate_hosting: 5,
        free_vps_bridge: 6,
        dual_server_upgrade: 7,
        pay_monthly_paypal: 8,
        pay_monthly_crypto: 9
      };
      return order[id] || 99;
    }

    function setActionBar(actions) {
      const list = (Array.isArray(actions) ? actions : [])
        .filter((a) => a && a.url)
        .slice()
        .sort((a, b) => actionPriority(a.id) - actionPriority(b.id))
        .slice(0, 4);
      actionBar.innerHTML = "";
      if (!list.length) {
        actionBar.style.display = "none";
        return;
      }
      for (const a of list) {
        const btn = document.createElement("button");
        btn.type = "button";
        btn.className = "actionBtn" + (a.id === "install_ai_webadmin_plugin" ? " primary" : "");
        btn.textContent = a.label || "Open";
        btn.addEventListener("click", () => openSite(a.url));
        actionBar.appendChild(btn);
      }
      actionBar.style.display = "flex";
    }

    function addInlineActionButton(label, onClick) {
      const row = document.createElement("div");
      row.className = "ctaRow";
      const btn = document.createElement("button");
      btn.type = "button";
      btn.className = "ctaBtn primary";
      btn.textContent = label;
      btn.addEventListener("click", onClick);
      row.appendChild(btn);
      chat.appendChild(row);
      chat.scrollTop = chat.scrollHeight;
    }

    async function startOnchainClaim() {
      if (!sessionId || !walletSession || walletSession.protocol !== "solana") {
        addMsg("ai", "On-chain claim is only available for Solana wallets right now.");
        return;
      }
      try {
        const prep = await workerFetch("/wallet/claim/prepare", {
          method: "POST",
          headers: { "content-type": "application/json" },
          body: JSON.stringify({ session_id: sessionId }),
        });
        const prepData = await prep.json();
        if (!prep.ok || !prepData?.ok) {
          addMsg("ai", prepData?.error || "Could not prepare on-chain claim.");
          return;
        }
        if (prepData.already_claimed) {
          addMsg("ai", "On-chain claim already recorded for this wallet.");
          return;
        }
        const solanaWeb3 = await loadSolanaWeb3();
        if (!solanaWeb3) throw new Error("Solana web3 not available.");
        const provider = window.phantom?.solana || window.solana;
        if (!provider || !provider.isPhantom) throw new Error("Phantom Solana wallet was not detected.");
        const connection = new solanaWeb3.Connection(prepData.rpc_url, "confirmed");
        const memoProgram = new solanaWeb3.PublicKey(prepData.memo_program);
        const memoData = new TextEncoder().encode(String(prepData.memo || ""));
        const memoIx = new solanaWeb3.TransactionInstruction({
          keys: [],
          programId: memoProgram,
          data: memoData,
        });
        const tx = new solanaWeb3.Transaction().add(memoIx);
        const { blockhash, lastValidBlockHeight } = await connection.getLatestBlockhash("confirmed");
        tx.recentBlockhash = blockhash;
        tx.feePayer = new solanaWeb3.PublicKey(walletSession.address);
        const signed = await provider.signAndSendTransaction(tx, { preflightCommitment: "confirmed" });
        const signature = String(signed?.signature || signed);
        if (!signature) throw new Error("No signature returned from wallet.");
        await connection.confirmTransaction({ signature, blockhash, lastValidBlockHeight }, "confirmed");
        const confirm = await workerFetch("/wallet/claim/confirm", {
          method: "POST",
          headers: { "content-type": "application/json" },
          body: JSON.stringify({ session_id: sessionId, txid: signature }),
        });
        const confirmData = await confirm.json();
        if (!confirm.ok || !confirmData?.ok) {
          addMsg("ai", confirmData?.error || "Could not confirm on-chain claim.");
          return;
        }
        addMsg("ai", `On-chain claim recorded. Tx: ${confirmData.txid}`);
      } catch (error) {
        addMsg("ai", String(error?.message || "On-chain claim failed."));
      }
    }

    function shouldShowYesNoButtons(aiText) {
      const t = String(aiText || "").toLowerCase();
      const patterns = [
        "is that correct",
        "is that your website",
        "want me to do that",
        "want me to run the scan",
        "would you be willing",
        "would you like me to build",
        "overall happy",
      ];
      if (patterns.some(p => t.includes(p))) return true;
      if (t.includes("?") && (t.includes("would you") || t.includes("is that") || t.includes("want"))) return true;
      return false;
    }

    function setYesNoUI(on) {
      quickBar.style.display = on ? "flex" : "none";
    }

    function setSmartOptions(aiText, payload = null) {
      const t = String(aiText || "").toLowerCase();
      const options = [];
      const paletteOptions = Array.isArray(payload?.palette_options) ? payload.palette_options : [];

      if (paletteOptions.length) {
        for (const p of paletteOptions.slice(0, 3)) {
          const id = String(p?.id || "").trim().toUpperCase();
          const name = String(p?.name || "").trim();
          if (!id) continue;
          options.push({ label: `Palette ${id}${name ? ` (${name})` : ""}`, value: id });
        }
      }

      if (t.includes('reply "opened"') || t.includes("when you're ready, open this link")) {
        options.push({ label: "Opened", value: "opened" });
        options.push({ label: "Different site", value: "different site" });
      }
      if (t.includes("(modern / bold)")) {
        options.push({ label: "Modern", value: "modern" });
        options.push({ label: "Bold", value: "bold" });
        options.push({ label: "Not sure", value: "not sure" });
      }
      if (t.includes("too bright / too dark / just right")) {
        options.push({ label: "Too bright", value: "too bright" });
        options.push({ label: "Too dark", value: "too dark" });
        options.push({ label: "Just right", value: "just right" });
      }
      if (t.includes("easy to read / cluttered / too empty")) {
        options.push({ label: "Easy to read", value: "easy to read" });
        options.push({ label: "Cluttered", value: "cluttered" });
        options.push({ label: "Too empty", value: "too empty" });
      }

      const numberedMatches = [...String(aiText || "").matchAll(/\b([1-3])\)\s+([^\n]+)/g)];
      if (numberedMatches.length >= 2) {
        for (const m of numberedMatches.slice(0, 3)) {
          options.push({ label: `${m[1]}) ${String(m[2]).trim().slice(0, 24)}`, value: m[1] });
        }
      }

      const seen = new Set();
      const deduped = options.filter((o) => {
        const key = `${o.label}|${o.value}`;
        if (seen.has(key)) return false;
        seen.add(key);
        return true;
      }).slice(0, 6);

      smartBar.innerHTML = "";
      if (!deduped.length) {
        smartBar.style.display = "none";
        return;
      }

      for (const opt of deduped) {
        const b = document.createElement("button");
        b.type = "button";
        b.className = "smartBtn";
        b.textContent = opt.label;
        b.addEventListener("click", async () => {
          if (pendingRequest) return;
          addMsg("me", opt.value);
          try {
            await callWorkerAnswer(opt.value);
          } catch {
            addMsg("ai", "Network/CORS error. Check DevTools console.");
            setRequestPending(false);
          }
        });
        smartBar.appendChild(b);
      }
      smartBar.style.display = "flex";
    }

    function setRequestPending(isPending) {
      pendingRequest = isPending;
      input.disabled = isPending || !sessionId;
      sendBtn.disabled = isPending || !sessionId;
      btnYes.disabled = isPending;
      btnNo.disabled = isPending;
      const smartButtons = smartBar.querySelectorAll("button");
      for (const b of smartButtons) b.disabled = isPending;
      const actionButtons = actionBar.querySelectorAll("button");
      for (const b of actionButtons) b.disabled = isPending;
    }

    async function loadSecurityConfig() {
      try {
        const r = await workerFetch("/security/config", { method: "GET" });
        const data = await r.json();
        if (r.ok && data && data.ok) {
          securityConfig = {
            turnstile_required: Boolean(data.turnstile_required),
            turnstile_site_key: data.turnstile_site_key || null,
            wallet_login_enabled: data.wallet_login_enabled !== false,
            walletconnect_project_id: data.walletconnect_project_id || null,
          };
        }
      } catch {}
      return securityConfig;
    }

    function loadTurnstileScript() {
      if (window.turnstile) return Promise.resolve();
      if (turnstileScriptPromise) return turnstileScriptPromise;
      turnstileScriptPromise = new Promise((resolve, reject) => {
        const s = document.createElement("script");
        s.src = "https://challenges.cloudflare.com/turnstile/v0/api.js?render=explicit";
        s.async = true;
        s.defer = true;
        s.onload = () => resolve();
        s.onerror = () => reject(new Error("Could not load security challenge."));
        document.head.appendChild(s);
      });
      return turnstileScriptPromise;
    }

    function handleTurnstileSuccess(token) {
      if (turnstileResolve) turnstileResolve(String(token || ""));
    }
    function handleTurnstileError() {
      if (turnstileReject) turnstileReject(new Error("Security challenge failed."));
    }

    async function ensureTurnstileToken() {
      if (!securityConfig.turnstile_required) return null;
      if (!securityConfig.turnstile_site_key) throw new Error("Security challenge is not configured.");
      await loadTurnstileScript();
      const mount = document.getElementById("turnstileMount");
      if (!window.turnstile || !mount) throw new Error("Security challenge unavailable.");

      if (turnstileWidgetId === null) {
        turnstileWidgetId = window.turnstile.render(mount, {
          sitekey: securityConfig.turnstile_site_key,
          size: "invisible",
          callback: handleTurnstileSuccess,
          "error-callback": handleTurnstileError,
          "expired-callback": handleTurnstileError,
          action: "start",
        });
      }

      return await new Promise((resolve, reject) => {
        let done = false;
        const finish = (fn, value) => {
          if (done) return;
          done = true;
          turnstileResolve = null;
          turnstileReject = null;
          clearTimeout(timeout);
          fn(value);
        };
        const timeout = setTimeout(() => finish(reject, new Error("Security challenge timed out.")), 15000);
        turnstileResolve = (token) => finish(resolve, token);
        turnstileReject = (error) => finish(reject, error || new Error("Security challenge failed."));
        try {
          window.turnstile.reset(turnstileWidgetId);
          window.turnstile.execute(turnstileWidgetId);
        } catch (error) {
          finish(reject, error);
        }
      });
    }

    function setStartHint(text, isError = false) {
      if (!startHint) return;
      startHint.textContent = String(text || "");
      startHint.style.color = isError ? "#9d1c1c" : "var(--muted)";
    }

    function setStartButtonsDisabled(disabled) {
      const buttons = [startNameBtn, walletMetaMaskBtn, walletConnectBtn, walletLedgerBtn, walletPhantomBtn];
      for (const b of buttons) {
        if (b) b.disabled = Boolean(disabled);
      }
    }

    function bytesToBase64(bytes) {
      const arr = bytes instanceof Uint8Array ? bytes : new Uint8Array(bytes || []);
      let s = "";
      for (let i = 0; i < arr.length; i += 1) s += String.fromCharCode(arr[i]);
      return btoa(s);
    }

    async function fetchWalletChallenge(provider, protocol) {
      const q = new URLSearchParams({ provider: String(provider || ""), protocol: String(protocol || "evm") });
      const r = await workerFetch(`/auth/wallet/challenge?${q.toString()}`, { method: "GET" });
      const data = await r.json();
      if (!r.ok || !data?.ok) {
        throw new Error(String(data?.error || "Could not create wallet challenge."));
      }
      return data;
    }

    async function loadWalletConnectScript() {
      if (window.WalletConnectEthereumProvider) return;
      if (!walletConnectScriptPromise) {
        walletConnectScriptPromise = new Promise((resolve, reject) => {
          const s = document.createElement("script");
          s.src = "https://unpkg.com/@walletconnect/ethereum-provider@2.21.1/dist/index.umd.js";
          s.async = true;
          s.defer = true;
          s.onload = () => resolve();
          s.onerror = () => reject(new Error("Could not load WalletConnect."));
          document.head.appendChild(s);
        });
      }
      await walletConnectScriptPromise;
    }

    async function getWalletConnectProvider() {
      const projectId = String(securityConfig.walletconnect_project_id || "").trim();
      if (!projectId) throw new Error("WalletConnect is not configured yet.");
      await loadWalletConnectScript();
      if (!window.WalletConnectEthereumProvider?.init) throw new Error("WalletConnect provider unavailable.");
      if (!walletConnectProvider) {
        walletConnectProvider = await window.WalletConnectEthereumProvider.init({
          projectId,
          chains: [1],
          optionalChains: [10, 56, 137, 8453, 42161, 43114],
          showQrModal: true,
          methods: ["personal_sign", "eth_sign", "eth_sendTransaction"],
          optionalMethods: ["wallet_switchEthereumChain", "eth_chainId"],
          optionalEvents: ["chainChanged", "accountsChanged"],
        });
      }
      return walletConnectProvider;
    }

    async function signWithEvmProvider(provider, address, message) {
      try {
        return await provider.request({ method: "personal_sign", params: [message, address] });
      } catch {
        return await provider.request({ method: "eth_sign", params: [address, message] });
      }
    }

    function pickMetaMaskProvider() {
      const eth = window.ethereum;
      if (!eth) return null;
      if (Array.isArray(eth.providers) && eth.providers.length) {
        return eth.providers.find((p) => p && p.isMetaMask) || eth.providers[0];
      }
      return eth;
    }

    async function connectEvmWallet(providerName) {
      let provider = null;
      if (providerName === "metamask") {
        provider = pickMetaMaskProvider();
        if (!provider) throw new Error("MetaMask was not detected.");
      } else if (providerName === "phantom") {
        provider = window.phantom?.ethereum || null;
        if (!provider) throw new Error("Phantom EVM wallet was not detected.");
      } else if (providerName === "walletconnect" || providerName === "ledger") {
        provider = await getWalletConnectProvider();
      } else {
        throw new Error("Unsupported EVM wallet.");
      }

      const challenge = await fetchWalletChallenge(providerName, "evm");
      const accounts = await provider.request({ method: "eth_requestAccounts" });
      const address = Array.isArray(accounts) ? String(accounts[0] || "") : "";
      if (!address) throw new Error("No wallet account was returned.");
      const chainId = await provider.request({ method: "eth_chainId" });
      const signature = await signWithEvmProvider(provider, address, challenge.message);
      return {
        provider: providerName,
        protocol: "evm",
        address,
        chain_id: chainId,
        nonce: challenge.nonce,
        message: challenge.message,
        signature,
      };
    }

    async function connectPhantomSolana() {
      const provider = window.phantom?.solana || window.solana;
      if (!provider || !provider.isPhantom) throw new Error("Phantom Solana wallet was not detected.");
      const challenge = await fetchWalletChallenge("phantom", "solana");
      await provider.connect();
      const encoded = new TextEncoder().encode(challenge.message);
      const signed = await provider.signMessage(encoded, "utf8");
      const address = String(signed?.publicKey?.toString?.() || provider?.publicKey?.toString?.() || "");
      const signatureBytes = signed?.signature instanceof Uint8Array ? signed.signature : new Uint8Array(signed?.signature || []);
      if (!address || !signatureBytes.length) throw new Error("Phantom did not return a valid signature.");
      return {
        provider: "phantom",
        protocol: "solana",
        address,
        chain_id: "solana:mainnet-beta",
        nonce: challenge.nonce,
        message: challenge.message,
        signature: bytesToBase64(signatureBytes),
      };
    }

    let solanaWeb3ScriptPromise = null;
    async function loadSolanaWeb3() {
      if (window.solanaWeb3) return window.solanaWeb3;
      if (!solanaWeb3ScriptPromise) {
        solanaWeb3ScriptPromise = new Promise((resolve, reject) => {
          const s = document.createElement("script");
          s.src = "https://unpkg.com/@solana/web3.js@1.95.4/lib/index.iife.min.js";
          s.async = true;
          s.onload = () => resolve(window.solanaWeb3);
          s.onerror = () => reject(new Error("Failed to load Solana web3."));
          document.head.appendChild(s);
        });
      }
      return solanaWeb3ScriptPromise;
    }

    async function startSession(payload) {
      await loadSecurityConfig();
      let turnstileToken = null;
      try {
        turnstileToken = await ensureTurnstileToken();
      } catch {
        throw new Error("Security check failed. Please refresh and try again.");
      }

      const r = await workerFetch("/q1/start", {
        method: "POST",
        headers: { "content-type": "application/json" },
        body: JSON.stringify({ ...payload, turnstile_token: turnstileToken }),
      });
      const data = await r.json();
      if (!r.ok || !data?.ok) throw new Error(String(data?.error || "Could not start chat."));
      sessionId = data.session_id;
      state = data.next_state;
      if (startPanel) startPanel.style.display = "none";
      bumpJackpotOnAuth();
      input.disabled = false;
      sendBtn.disabled = false;
      addMsg("ai", data.prompt);
      if (data.billing) {
        renderBillingConfig(data.billing);
        renderBillingStatus(data.billing);
        addMsg(
          "ai",
          `Starter balance: ${Number(data.billing.token_balance || 0)} ${data.billing.spl_symbol || "SPL"} tokens` +
            (data.billing.points_enabled ? ` and ${Number(data.billing.points_balance || 0)} ${data.billing.points_symbol || "PTS"} points.` : ".")
        );
        if (data.billing.pricing_model) {
          addMsg("ai", formatPricingModel(data.billing.pricing_model));
        }
        if (walletSession?.protocol === "solana" && !data.billing.onchain_claimed && !onchainClaimShown) {
          onchainClaimShown = true;
          addMsg(
            "ai",
            "Optional: record a one-time on-chain claim (memo-only transaction) so your wallet is eligible for future rewards."
          );
          addInlineActionButton("Record On-chain Claim", startOnchainClaim);
        }
      }
      await loadBillingStatus();
      setYesNoUI(shouldShowYesNoButtons(data.prompt));
      setSmartOptions(data.prompt, data);
      input.focus();
    }

    async function callWorkerAnswer(text) {
      if (pendingRequest) return;
      setRequestPending(true);
      try {
        const r = await workerFetch("/q1/answer", {
          method: "POST",
          headers: {"content-type":"application/json"},
          body: JSON.stringify({ session_id: sessionId, state, answer: text })
        });

        const data = await r.json();
        if (!data.ok) {
          if (data.code === "SECURITY_VERIFICATION_REQUIRED") {
            addMsg("ai", "Security verification expired. Please refresh to restart securely.");
          } else {
            addMsg("ai", "Error: " + (data.error || "unknown"));
          }
          return;
        }

        state = data.next_state;

        if (data.open_url) {
          openSite(data.open_url);
          addOpenLinkButton(data.open_url, "Open Suggested Link (new tab)");
        }

        addMsg("ai", data.prompt);

        if (data.demo_url) {
          addDemoButton(data.demo_url);
        }

        if (data.color_swatches) {
          addColorSwatches(data.color_swatches);
        }

        if (Array.isArray(data.cta_actions) && data.cta_actions.length) {
          addCtaActions(data.cta_actions);
          setActionBar(data.cta_actions);
        } else if (Array.isArray(data.plugin_step_actions) && data.plugin_step_actions.length) {
          const pluginActions = data.plugin_step_actions.map((s) => ({
            id: s.id,
            url: s.url,
            label: `${s.step}) ${s.label}`
          }));
          addCtaActions(pluginActions);
          setActionBar(pluginActions);
        }

        setYesNoUI(shouldShowYesNoButtons(data.prompt));
        setSmartOptions(data.prompt, data);

        if (Array.isArray(data.palette_options) && data.palette_options.length) {
          addPaletteOptions(data.palette_options);
        }

        if (autoAdvanceTimer) {
          clearTimeout(autoAdvanceTimer);
          autoAdvanceTimer = null;
        }

        if (data.auto_advance_after_seconds && data.auto_advance_answer) {
          const secs = Number(data.auto_advance_after_seconds);
          if (Number.isFinite(secs) && secs > 0) {
            autoAdvanceTimer = setTimeout(async () => {
              try {
                if (pendingRequest) return;
                await callWorkerAnswer(String(data.auto_advance_answer));
              } catch {
                addMsg("ai", "I could not auto-continue. Reply when you are ready.");
              }
            }, secs * 1000);
          }
        }
      } finally {
        setRequestPending(false);
      }
    }

    btnYes.addEventListener("click", async () => {
      if (pendingRequest) return;
      addMsg("me", "yes");
      try {
        await callWorkerAnswer("yes");
      } catch {
        addMsg("ai", "Network/CORS error. Check DevTools console.");
        setRequestPending(false);
      }
    });
    btnNo.addEventListener("click", async () => {
      if (pendingRequest) return;
      addMsg("me", "no");
      try {
        await callWorkerAnswer("no");
      } catch {
        addMsg("ai", "Network/CORS error. Check DevTools console.");
        setRequestPending(false);
      }
    });

    async function startWithName() {
      const firstName = (prompt("First Name?") || "").trim();
      const lastName = (prompt("Last Name?") || "").trim();
      if (!firstName || !lastName) {
        setStartHint("Please enter both first and last name to continue.", true);
        return;
      }
      await startSession({ FirstName: firstName, LastName: lastName, login_method: "name" });
    }

    async function startWithWallet(providerName) {
      const provider = String(providerName || "").toLowerCase();
      if (!provider) return;

      let walletAuth = null;
      if (provider === "metamask") {
        walletAuth = await connectEvmWallet("metamask");
      } else if (provider === "walletconnect") {
        walletAuth = await connectEvmWallet("walletconnect");
      } else if (provider === "ledger") {
        walletAuth = await connectEvmWallet("ledger");
      } else if (provider === "phantom") {
        if (window.phantom?.solana || window.solana?.isPhantom) {
          walletAuth = await connectPhantomSolana();
        } else {
          walletAuth = await connectEvmWallet("phantom");
        }
      } else {
        throw new Error("Unsupported wallet option.");
      }

      walletSession = walletAuth;
      await startSession({ login_method: "wallet", wallet_auth: walletAuth });
    }

    async function handleStartAction(action) {
      if (pendingRequest) return;
      setRequestPending(true);
      setStartButtonsDisabled(true);
      setStartHint("Connecting…");
      try {
        if (action === "name") {
          await startWithName();
        } else {
          await startWithWallet(action);
        }
        setStartHint("Connected.");
      } catch (error) {
        setStartHint(String(error?.message || "Start failed. Please try again."), true);
      } finally {
        setRequestPending(false);
        if (!sessionId) setStartButtonsDisabled(false);
      }
    }

    form.addEventListener("submit", async (e) => {
      e.preventDefault();
      const text = input.value.trim();
      if (!text) return;

      if (!sessionId || !state) {
        addMsg("ai", "Session not started yet. Refresh the page to begin.");
        return;
      }

      input.value = "";
      addMsg("me", text);

      try {
        await callWorkerAnswer(text);
      } catch {
        addMsg("ai", "Network/CORS error. Check DevTools console.");
        setRequestPending(false);
      }
    });

    startNameBtn.addEventListener("click", () => handleStartAction("name"));
    walletMetaMaskBtn.addEventListener("click", () => handleStartAction("metamask"));
    walletConnectBtn.addEventListener("click", () => handleStartAction("walletconnect"));
    walletLedgerBtn.addEventListener("click", () => handleStartAction("ledger"));
    walletPhantomBtn.addEventListener("click", () => handleStartAction("phantom"));

    loadSecurityConfig().then((cfg) => {
      if (!cfg.walletconnect_project_id) {
        walletConnectBtn.title = "WalletConnect project id is not configured yet.";
        walletLedgerBtn.title = "WalletConnect project id is not configured yet.";
      }
    });

    loadBillingConfig();
    startJackpotTicker();
  </script>
</body>
</html>
